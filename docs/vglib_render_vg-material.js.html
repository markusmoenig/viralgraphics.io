<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>ViralGraphics.io Source: vglib/render/vg-material.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.spacelab.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">ViralGraphics.io</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="VG.html">VG</a></li><li><a href="VG.context.html">VG.context</a></li><li><a href="VG.Controller.html">VG.Controller</a></li><li><a href="VG.Core.html">VG.Core</a></li><li><a href="VG.Data.html">VG.Data</a></li><li><a href="VG.Events.html">VG.Events</a></li><li><a href="VG.Font.html">VG.Font</a></li><li><a href="VG.Import.html">VG.Import</a></li><li><a href="VG.Math.html">VG.Math</a></li><li><a href="VG.Render.html">VG.Render</a></li><li><a href="VG.UI.html">VG.UI</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="RichText.Editor.html">RichText.Editor</a></li><li><a href="RichText.ElementManager.html">RichText.ElementManager</a></li><li><a href="VG.Canvas.html">VG.Canvas</a></li><li><a href="VG.Controller.Array.html">VG.Controller.Array</a></li><li><a href="VG.Controller.Base.html">VG.Controller.Base</a></li><li><a href="VG.Controller.Tree.html">VG.Controller.Tree</a></li><li><a href="VG.Core.Color.html">VG.Core.Color</a></li><li><a href="VG.Core.Image.html">VG.Core.Image</a></li><li><a href="VG.Core.ImagePool.html">VG.Core.ImagePool</a></li><li><a href="VG.Core.Margin.html">VG.Core.Margin</a></li><li><a href="VG.Core.Material.html">VG.Core.Material</a></li><li><a href="VG.Core.NormalizedColor.html">VG.Core.NormalizedColor</a></li><li><a href="VG.Core.Point.html">VG.Core.Point</a></li><li><a href="VG.Core.Rect.html">VG.Core.Rect</a></li><li><a href="VG.Core.Size.html">VG.Core.Size</a></li><li><a href="VG.Core.Timer.html">VG.Core.Timer</a></li><li><a href="VG.Core.TypedArray.html">VG.Core.TypedArray</a></li><li><a href="VG.Data.Base.html">VG.Data.Base</a></li><li><a href="VG.Data.Collection.html">VG.Data.Collection</a></li><li><a href="VG.Data.UndoItem.html">VG.Data.UndoItem</a></li><li><a href="VG.Events.MouseDownEvent.html">VG.Events.MouseDownEvent</a></li><li><a href="VG.Events.MouseMoveEvent.html">VG.Events.MouseMoveEvent</a></li><li><a href="VG.Events.MouseUpEvent.html">VG.Events.MouseUpEvent</a></li><li><a href="VG.Font.Font.html">VG.Font.Font</a></li><li><a href="VG.Font.Manager.html">VG.Font.Manager</a></li><li><a href="VG.GPUBuffer.html">VG.GPUBuffer</a></li><li><a href="VG.Math.Aabb.html">VG.Math.Aabb</a></li><li><a href="VG.Math.Matrix4.html">VG.Math.Matrix4</a></li><li><a href="VG.Math.Quat.html">VG.Math.Quat</a></li><li><a href="VG.Math.Vector2.html">VG.Math.Vector2</a></li><li><a href="VG.Math.Vector3.html">VG.Math.Vector3</a></li><li><a href="VG.Math.Vector4.html">VG.Math.Vector4</a></li><li><a href="VG.Render.BoxMesh.html">VG.Render.BoxMesh</a></li><li><a href="VG.Render.Camera.html">VG.Render.Camera</a></li><li><a href="VG.Render.Context.html">VG.Render.Context</a></li><li><a href="VG.Render.Material.html">VG.Render.Material</a></li><li><a href="VG.Render.Mesh.html">VG.Render.Mesh</a></li><li><a href="VG.Render.MtlMaterial.html">VG.Render.MtlMaterial</a></li><li><a href="VG.Render.OrbitCamera.html">VG.Render.OrbitCamera</a></li><li><a href="VG.Render.Pipeline.html">VG.Render.Pipeline</a></li><li><a href="VG.Render.SceneManager.html">VG.Render.SceneManager</a></li><li><a href="VG.Render.SceneNode.html">VG.Render.SceneNode</a></li><li><a href="VG.Render.SimpleMaterial.html">VG.Render.SimpleMaterial</a></li><li><a href="VG.Render.SphereMesh.html">VG.Render.SphereMesh</a></li><li><a href="VG.RenderTarget.html">VG.RenderTarget</a></li><li><a href="VG.Shader.html">VG.Shader</a></li><li><a href="VG.Texture.html">VG.Texture</a></li><li><a href="VG.UI.Button.html">VG.UI.Button</a></li><li><a href="VG.UI.CheckBox.html">VG.UI.CheckBox</a></li><li><a href="VG.UI.CodeEdit.html">VG.UI.CodeEdit</a></li><li><a href="VG.UI.ColorWheel.html">VG.UI.ColorWheel</a></li><li><a href="VG.UI.Dialog.html">VG.UI.Dialog</a></li><li><a href="VG.UI.DockWidget.html">VG.UI.DockWidget</a></li><li><a href="VG.UI.DropArea.html">VG.UI.DropArea</a></li><li><a href="VG.UI.DropDownMenu.html">VG.UI.DropDownMenu</a></li><li><a href="VG.UI.HtmlView.html">VG.UI.HtmlView</a></li><li><a href="VG.UI.HtmlWidget.html">VG.UI.HtmlWidget</a></li><li><a href="VG.UI.IconWidget.html">VG.UI.IconWidget</a></li><li><a href="VG.UI.Image.html">VG.UI.Image</a></li><li><a href="VG.UI.Label.html">VG.UI.Label</a></li><li><a href="VG.UI.LabelLayout.html">VG.UI.LabelLayout</a></li><li><a href="VG.UI.Layout.html">VG.UI.Layout</a></li><li><a href="VG.UI.ListWidget.html">VG.UI.ListWidget</a></li><li><a href="VG.UI.ProgressDialog.html">VG.UI.ProgressDialog</a></li><li><a href="VG.UI.RenderWidget.html">VG.UI.RenderWidget</a></li><li><a href="VG.UI.SectionBar.html">VG.UI.SectionBar</a></li><li><a href="VG.UI.SectionBarButton.html">VG.UI.SectionBarButton</a></li><li><a href="VG.UI.SectionBarSeparator.html">VG.UI.SectionBarSeparator</a></li><li><a href="VG.UI.SectionToolBar.html">VG.UI.SectionToolBar</a></li><li><a href="VG.UI.Slider.html">VG.UI.Slider</a></li><li><a href="VG.UI.SplitLayout.html">VG.UI.SplitLayout</a></li><li><a href="VG.UI.StackedLayout.html">VG.UI.StackedLayout</a></li><li><a href="VG.UI.StatusBar.html">VG.UI.StatusBar</a></li><li><a href="VG.UI.StatusDialog.html">VG.UI.StatusDialog</a></li><li><a href="VG.UI.TabWidget.html">VG.UI.TabWidget</a></li><li><a href="VG.UI.TextEdit.html">VG.UI.TextEdit</a></li><li><a href="VG.UI.TextLineEdit.html">VG.UI.TextLineEdit</a></li><li><a href="VG.UI.TreeWidget.html">VG.UI.TreeWidget</a></li><li><a href="VG.UI.Widget.html">VG.UI.Widget</a></li><li><a href="VG.UI.Window.html">VG.UI.Window</a></li><li><a href="VG.UI.Workspace.html">VG.UI.Workspace</a></li><li><a href="VG.WebGL.html">VG.WebGL</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="tutorials.list.html" class="dropdown-toggle" data-toggle="dropdown">Tutorials<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="tutorial-Data Model.html">Data Model</a></li><li><a href="tutorial-Layouts.html">Layouts</a></li><li><a href="tutorial-Widget Basics.html">Widget Basics</a></li><li><a href="tutorial-Workspace.html">Workspace</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html#false">false</a></li><li><a href="global.html#null">null</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: vglib/render/vg-material.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/*
 * Copyright (c) 2014-2017 Markus Moenig &lt;markusm@visualgraphics.tv> and Contributors
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

 /** Material interface, derived classes must create a shader and
  *  optionally override the bind method
  *  @constructor */

VG.Render.Material = function()
{
    /** The shader object
     *  @member {VG.Shader} */
    this.shader = null;
};

/** Checks if the material has a valid shader, otherwise returns false
 *  @return {Bool} */

VG.Render.Material.prototype.isValid = function()
{
    return (this.shader);
};

/** Binds the shader, override for more complex binding */

VG.Render.Material.prototype.bind = function()
{
    if (this.shader) this.shader.bind();
};

/** Deleted the material */

VG.Render.Material.prototype.dispose = function()
{
	if (this.shader)
	{
		this.shader.dispose();
		this.shader = null;
	}
};

/** Sets a model-view matrix from a float array, the matrial(i.e. shader) must be binded before.
 *  @param {array} value - A float array (2x2, 3x3 or 4x4) : column major
 *  @param {bool} [false] transpose - If true transposes the matrix
 */

VG.Render.Material.prototype.setModelViewMatrix = function(matrix, transpose)
{
	if (this.shader)
		// the uniform {string} may be different according to material implementation.
		this.shader.setMatrix("mvM", matrix, transpose);
};

/** Sets a projection matrix from a float array, the matrial(i.e. shader) must be binded before.
 *  @param {array} value - A float array (2x2, 3x3 or 4x4) : column major
 *  @param {bool} [false] transpose - If true transposes the matrix
 */

VG.Render.Material.prototype.setProjectionMatrix = function(matrix, transpose)
{
	if (this.shader)
		// the uniform {string} may be different according to material implementation.
		this.shader.setMatrix("projM", matrix, transpose);
};

/** Queries the attribute location/index
 *  @param {string} name - The attribute name as set in the source
 *  @returns {number}
 */

VG.Render.Material.prototype.getAttrib = function(name)
{
	var attrib = -1;
	if (this.shader)
		attrib = this.shader.getAttrib(name);
	return attrib;
};

/** Applies sub material.
 *  @param {int} subIndex - The sub material(index) for facet
 */

VG.Render.Material.prototype.applySubMaterial = function(subIndex)
{
};

/** Applies global lights.
 *  @param {Array[VG.Render.Light]} lights
 */

VG.Render.Material.prototype.applyLights = function(lights)
{
};

/** Barebone material, mostly used as fail-over
 * @augments VG.Render.Material
 * @constructor */

VG.Render.SimpleMaterial = function()
{
    VG.Render.Material.call(this);

    var vSrc = [
        '#version 100',
        'attribute vec4 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',

        'uniform mat4 mvM;',
        'uniform mat4 projM;',

        'varying vec3 vN;',

        'void main() {',
        '   vN = (mvM * vec4(normal, 0.0)).xyz;',
        '   vec4 pos = mvM * position;',
        '   gl_Position = projM * pos;',
        '}',
    ].join("\n");

    var fSrc = [
        '#version 100',
        'precision mediump float;',

        'varying vec3 vN;',

        'void main() {',
        '   vec3 L = normalize(vec3(-0.5, 0.5, 0.5));',
        '   vec3 N = normalize(vN);',

        '   vec3 color = vec3(0.2, 0.2, 0.3) + vec3(0.5, 0.5, 1.0) * clamp(dot(L, N), 0.0, 1.0);',

        '   gl_FragColor = vec4(color, 1.0);',
        '}'
    ].join("\n");

    this.shader = new VG.Shader(vSrc, fSrc);
    this.shader.depthTest = true;
    this.shader.depthWrite = true;

    this.shader.create();
};

VG.Render.SimpleMaterial.prototype = Object.create(VG.Render.Material.prototype);

/**
 * Material that conforms to mtl file format
 * Opt format:
 * 		command options
 * 		.... (one or more)
 * 	example:
 *	 var reflectMtl = new VG.Render.MtlMaterial({
 *		Ka: [1, 1, 0],
 *		Kd: [1, 1, 0],
 *		Ks: [1, 1, 1],
 *		Ns: 100,
 *		refl: {
 *			cube_top: {filename: 'cube/cube_nx.png'},
 *			cube_bottom: {filename: 'cube/cube_px.png'},
 *			cube_front: {filename: 'cube/cube_py.png'},
 *			cube_back: {filename: 'cube/cube_ny.png'},
 *   	    cube_left: {filename: 'cube/cube_nz.png'},
 *	        cube_right: {filename: 'cube/cube_pz.png'}
 *       },
 *	   illum: 3
 *	});
 * @constructor
 * @augments VG.Render.Material
 */

VG.Render.MtlMaterial = function(opt){
	VG.Render.Material.call(this);
	this.opt = opt;
	this.className = "MtlMaterial";
	this.needsUpdate = true; // force compilation upon first bind
	this.textureNeedsUpdate = true;
};
VG.Render.MtlMaterial.prototype = Object.create(VG.Render.Material.prototype);

/**
 * @param {Dictionary} images Map from filename to VG.Core.Image()
 */

VG.Render.MtlMaterial.prototype.createTexture = function(images) {
	var that = this;
	if(this.retryTimer &amp;&amp; this.retryTimer>0){
		this.retryTimer -= 1;
		return;
	}
	this.retryTimer = 10;
	if(!images) {
		images = {};
		VG.context.imagePool.images.forEach(function(o){
			if ( o.isValid() ) images[o.name] = o;
		});
	}
	this.textureNeedsUpdate = false;
	if (!VG.Render.MtlMaterial.notFoundImage) {
		var image = VG.Core.Image(2, 2);
		image.name = 'notFoundImage';
		image.setPixel(0, 0, 1, 1, 1, 1);
		image.setPixel(1, 1, 1, 1, 1, 0.5);
		image.setPixel(0, 1, 0, 0, 0, 0.5);
		image.setPixel(1, 0, 0, 0, 0, 0);
		VG.Render.MtlMaterial.notFoundImage = image;
	}
	['map_Ka', 'map_Kd', 'map_Ks', 'map_Ns', 'map_d',
		'decal', 'disp', 'bump'].forEach(function (o) {
			if(that.opt[o]) {
				var image = images[that.opt[o].filename];
				if(image) {
					that.opt[o].texture = new VG.Texture([
						image
					], false);
					that.opt[o].texture.flipY = false;
					that.opt[o].texture.create();
				} else {
					that.textureNeedsUpdate = true;
				}
			}
		});
	if(this.opt.refl){
		var fail = false;
		var sides = ['cube_top', 'cube_bottom', 'cube_front', 'cube_back', 'cube_left', 'cube_right'].map(function(o){
			if(that.opt.refl[o]){
				var image = images[that.opt.refl[o].filename];
				if (image) {
					return image;
				} else {
					fail = true;
				}
			}
		});
		if(fail){
			this.textureNeedsUpdate = true;
		} else {
			this.opt.refl.texture = new VG.Texture(sides, true);
			this.opt.refl.texture.flipY = false;
			this.opt.refl.texture.create();
		}
	}
};

/**
 * Since the mesh loaded from obj can contains children and grandchildren.
 * We need to create texture for each.
 * This static method will walk on the mesh tree to create texture for each material
 * with the corresponding images.
 */

VG.Render.MtlMaterial.recursiveCreateTexture = function(mesh, images)
{
	if(mesh.material &amp;&amp; mesh.material.createTexture){
		mesh.material.createTexture(images);
	}
	for(var i = 0; i &lt; mesh.children.length; i++){
		VG.Render.MtlMaterial.recursiveCreateTexture(mesh.children[i], images);
	}
};

	/**
	 * Compile this material shader with provided lights configuration.
	 * The compilation will depends on the feature used on the lights.
	 * If it use spot, point, directional or only ambient light,
	 * then only that part compiled in the shader.
	 * This will prevent bloated shader source.
	 * The specific value of each element, e.q. position does not determine
	 * the compilation, but the existence of that value will determine the result shader.
	 * User could change the value of light.position or this.opt.Kd without the need
	 * for recompilation.
	 * Recompilation needed if use change the tipe of light or the number of light.
	 * For example: adding position to light will change from global ambient
	 * to directional light.
	 *
	 * @param {Array} lights
	 *  each light is of format:
	 *      {
     *          color: {
     *              ambient: VG.Core.Color(),
     *              diffuse: VG.Core.Color(),
     *              specular: VG.Core.Color()
     *          },
     *          position: VG.Math.Vector4(), // set w = 0 for directional light
     *          // for directional light, specify the direction of light
     *          attenuation: {
     *              constant: 1.5,
     *              linear: 0.5,
     *              quadratic: 0.2
     *          },
     *          spot: {
     *              cos_of_cutoff: 0.5, // cosine of cutoff angle
     *              exponent: 2.0,
     *              direction: VG.Math.Vector3()
     *          },
     *          strength: 1.0 // used by embree only
     *      }
	 *      spot light require: spot
	 *      point light require: position (w!=0) and attenuation
	 *      directional light require: color, position (w==0)
	 *      ambient require: color.ambient
	 */

	/**
	 * reference: http://paulbourke.net/dataformats/mtl/
	 * Term	Definition
	 *
	 * Fr	Fresnel reflectance
	 * Ft	Fresnel transmittance
	 * Ia	ambient light
	 * I	light intensity
	 * Ir	intensity from reflected direction
	 * 		(reflection map and/or ray tracing)
	 * It	intensity from transmitted direction
	 * Ka	ambient reflectance
	 * Kd	diffuse reflectance
	 * Ks	specular reflectance
	 * Tf	transmission filter
	 *
	 * Vector	Definition
	 *
	 * H	unit vector bisector between L and V
	 * L	unit light vector
	 * N	unit surface normal
	 * V	unit view vector
	 */

VG.Render.MtlMaterial.prototype.compile = function(lights)
{
	this.flag = {
		use: {}
	}; // reset flag
	var flag = this.flag;
	var use = this.flag.use;
	var opt = this.opt;

	// choose the right illumination here if needed
	flag.illum = opt.illum;
	if (flag.illum === undefined) {
		if (opt.Ks) {
			flag.illum = 2;
		} else if(opt.Kd) {
			flag.illum = 1;
		} else {
			flag.illum = 0;
		}
	}
	var illum = flag.illum;
	// set flags
	if (illum === 0) {
		use.Kd = true;
	} else if (illum &lt;= 9) {
		use.Ka = true;
		use.Kd = true;
		use.normal = true;
		use.pos = true;
		if (illum >= 2) {
			use.Ks = true;
			use.Ns = true;

			use.reflect = illum >= 3;
			use.raytrace = illum >= 3 &amp;&amp; illum &lt;= 7;
			use.dissolve = illum == 4 || illum == 6 || illum == 7 || illum == 9;
			use.Fr = illum == 5 || illum == 7;
			use.refract = illum == 6 || illum == 7;
			use.reflect = use.reflect &amp;&amp; !!opt.refl;
			use.dissolve = use.dissolve &amp;&amp; !!opt.d;
			use.refract = use.refract &amp;&amp; use.dissolve &amp;&amp; !!opt.refl &amp;&amp; !!opt.Ni;
		}
	} else if (flag.illum === 10) {
		// shadow
	}
	// check if texture coord needed
	if ((use.Kd &amp;&amp; opt.map_Kd) || (use.Ks &amp;&amp; (opt.map_Ks || opt.map_Ns)) || (use.Ka &amp;&amp; opt.map_Ka)) {
		use.texCoord = true;
		use.texture = true;
	}
	if (use.reflect || use.refract) {
		use.texture = true;
	}
	function If(flag, text) {
		if (flag) return text;
		return "";
	}
	var v = [
		'#version 100',
		'attribute vec4 position;',
		'attribute vec3 normal;',
		If(use.texCoord, 'attribute vec2 texCoord;'),
		'uniform mat4 mvM;',
		'uniform mat4 projM;',
		If(use.reflect, 'uniform mat4 u_view;\nvarying mat3 v_view;'),
		If(use.normal, 'varying vec3 v_normal;'),
		If(use.pos, 'varying vec3 v_pos;'),
		If(use.texCoord, 'varying vec2 v_texCoord;'),
		'void main(){',
		If(use.normal, 'v_normal = (mvM * vec4(normal, 0.0)).xyz;'),
		'vec4 pos = mvM * position;',
		If(use.pos, 'v_pos = pos.xyz/pos.w;'),
		If(use.texCoord, 'v_texCoord = texCoord;'),
		If(use.reflect, 'v_view = mat3(u_view);'),
		'gl_Position = projM * pos;',
		'}'
	].join('\n');

	var f = [
		'#version 100',
		'precision highp float;',
		// starts uniform
		If(use.Ka, 'uniform vec3 Ka;' + If(opt.map_Ka, 'uniform sampler2D map_Ka;')),
		If(use.Kd, 'uniform vec3 Kd;' + If(opt.map_Kd, 'uniform sampler2D map_Kd;')),
		If(use.Ks, 'uniform vec3 Ks;' + If(opt.map_Ks, 'uniform sampler2D map_Ks;')),
		If(use.Ns, 'uniform float Ns;' + If(opt.map_Ns, 'uniform sampler2D map_Ns;')),
		If(use.reflect || use.refract, 'uniform samplerCube map_env;\nvarying mat3 v_view;'),
		If(use.refract, 'uniform float Tf;\n uniform float Ni;'),
		If(use.dissolve, 'uniform float dissolve;'),
		(function(){
			var light, name, out = '';
			for(var i in lights){
				light = lights[i];
				name = "L"+i;
				out += If(use.Ka, 'uniform vec3 '+name+'_col_a;\n');
				if (light.position &amp;&amp; (use.Ks || use.Kd)) {
					out += If(use.Kd, 'uniform vec3 ' + name + '_col_d;\n');
					out += If(use.Ks, 'uniform vec3 ' + name + '_col_s;\n');
					out += 'uniform vec4 '+name+'_pos;\n';
					use.att = light.position &amp;&amp; light.position.w !== 0;
					if(use.att) {
						out += 'uniform float ' + name + '_att_c;\n';
						out += 'uniform float ' + name + '_att_l;\n';
						out += 'uniform float ' + name + '_att_q;\n';
						if (light.spot) {
							out += 'uniform float ' + name + '_spot_cos;\n';
							out += 'uniform float ' + name + '_spot_exp;\n';
							out += 'uniform float ' + name + '_spot_dir;\n';
						}
					}
				}
			}
			return out;
		})(),
		// starts varying
		If(use.texCoord, 'varying vec2 v_texCoord;'),
		If(use.normal, 'varying vec3 v_normal;'),
		If(use.pos, 'varying vec3 v_pos;'),
		If(use.Fr, [
			'vec3 Fr(float hv, vec3 ks){',
			'return mix(ks, vec3(1.0), pow(1.0-max(0.0, hv), 5.0));',
			'}\n'
		].join('\n')),
		// here starts main
		'void main(){',
		If(use.Ka, 'vec3 KA = Ka' + If(opt.map_Ka, '*texture2D(map_Ka, v_texCoord).rgb') + ';'),
		If(use.Kd, 'vec3 KD = Kd' + If(opt.map_Kd, '*texture2D(map_Kd, v_texCoord).rgb') + ';'),
		If(flag.illum !== 0,[
			// material color + map join
			If(use.Ks, 'vec3 KS = Ks' + If(opt.map_Ks, '*texture2D(map_Ks, v_texCoord).rgb') + ';'),
			If(use.Ns, 'float NS = Ns' + If(opt.map_Ns, '*texture2D(map_Ns, v_texCoord).r') + ';'),
			// variables declarations
			If(use.Ka, 'vec3 ambient = vec3(0.0);'),
			If(use.Kd, 'vec3 diffuse = vec3(0.0);'),
			If(use.Ks, 'vec3 specular = vec3(0.0);'),
			'vec3 color = vec3(0.0);',
			'vec3 all = vec3(0.0);',
			'vec3 refl = vec3(0.0);',
			'vec3 pos_to_light = vec3(0.0);',
			'float dst = 0.0;',
			'float att = 0.0;',
			If(use.normal, 'vec3 normal = normalize(v_normal);'),
			If(use.pos, 'vec3 pos_to_eye = normalize(vec3(0.0)-v_pos);'),
		].join('\n')),
		(function(){
			var light, name, out = '';
			if (flag.illum === 0) {
				return 'gl_FragColor.rgb = KD;';
			}
			// KaIa
			// + Kd { SUM j=1..ls, (N*Lj)Ij }
			// + Ks ({ SUM j=1..ls, ((H*Hj)^Ns)Ij } + Ir)
			for(var i in lights) {
				light = lights[i];
				name = "L" + i;
				use.att = light.position &amp;&amp; light.position.w !== 0;
				if (use.att) {
					out += [
						"dst = distance(" + name + "_pos.xyz,v_pos);",
						"att = " + name + "_att_c + " + name + "_att_l * dst + " + name + "_att_q * dst * dst;",
						'att = 1.0/att;\n'
					].join('\n');
					if (light.spot) {
						out += [
							"cos_theta_spot = dot(v_pos - " + name + "_pos, " + name + "_spot_dir);",
							"if (cos_theta_spot>" + name + "_spot_cos) {",
							"att *= pow(cos_theta_spot, " + name + "_spot_exp);",
							'} else {',
							'att = 0.0;',
							'}\n'
						].join('\n');
					}
				}
				out += If(use.Ka, 'ambient += '+name+'_col_a' +If(use.att, ' * att') +';\n');

				if (use.Kd) {
					if (light.position) {
						if (light.position.w === 0) {
							out += 'pos_to_light = ' + name + '_pos.xyz;\n';
						} else {
							out += 'pos_to_light = normalize(' + name + '_pos.xyz - v_pos);\n';
						}
						out += 'diffuse += (' + name + '_col_d * max(0.0, dot(pos_to_light, normal)))' +
							If(use.att, ' * att') + ';\n';
						if (use.Ks) {
							out += 'refl = reflect(vec3(0.0) - pos_to_light, normal);\n';
							out += 'if(dot(pos_to_light, pos_to_eye) > 0.0){\n';
							out += 'specular += (' + name + '_col_s * pow(max(0.0, dot(pos_to_eye, refl)), NS))';
							if (use.Fr) {
								out += '*Fr(dot(normalize(pos_to_eye + pos_to_light), pos_to_eye), KS)';
							} else {
								out += '*KS';
							}
							out += If(use.att, '*att') + ';\n';
							out += '}\n';
						}
					}
				}
			}
			var arr = [], text;
			if(use.Ka){ arr.push('ambient * KA');}
			if(use.Kd){ arr.push('diffuse * KD');}
			if(use.Ks){ arr.push('specular');}
			if(use.reflect){
				text = 'KS';
				if (use.Fr) { text = 'Fr(dot(normal, pos_to_eye), KS)';}
				arr.push(text +  '* textureCube(map_env, v_view * reflect(pos_to_eye, normal)).rgb');
			}
			if(use.refract){
				out += [
					'float sinA = sqrt(1.0-dot(pos_to_eye,normal));',
					'float sinB = 1.0/Ni * sinA;',
					'float cosB = sqrt(1.0-sinB*sinB);',
					'vec3 T = normalize(cross(cross(pos_to_eye, normal), normal));',
					'vec3 ray = normalize(cosB * normal + sinB * T);\n'
				].join('\n');
				text = '';
				if (use.Fr) { text = 'Fr(dot(normal, pos_to_eye), 1.0-KS) * ';}
				arr.push(text + 'Tf * textureCube(map_env, v_view * ray).rgb * (1.0 - KS)');
			}
			if (arr.length > 0) {
				out += 'color = ' + arr.join('+') + ';\n';
			}
			out +='gl_FragColor.rgb = color;\n';
			if (use.dissolve) {
				out += 'gl_FragColor.a = dissolve;';
			}
			return out;
		})(),
		'}\n'
	].join('\n');
	//VG.log(flag.illum);
	//VG.log(v);
	//VG.log(f);
	//console.log(use);
	this.shader = new VG.Shader(v, f);
	this.shader.depthTest = true;
	this.shader.depthWrite = true;
	this.shader.create();
	if (use.dissolve) {
		this.shader.blendType = VG.Shader.Blend.Alpha;
	}
	this.needsUpdate = false;
};

/**
 * Bind this material shader.
 * It will bind necessary material value, texture, reflection map and light value.
 * It will recompile shader if this.needsUpdate is set.
 * Call this before drawing mesh that assume this material.
 *
 * @param {VG.Render.Context} context
 */

VG.Render.MtlMaterial.prototype.bind = function(context)
{
	var use, shader, slot = 0, opt = this.opt,
		lights = context.lights, camera = context.camera;
	if (this.needsUpdate) {
		this.needsUpdate = false;
		this.compile(lights);
	}
	use = this.flag.use;
	if (use.texture &amp;&amp; this.textureNeedsUpdate) {
		this.createTexture();
	}
	shader = this.shader;
	shader.bind();
	if(use.Ka &amp;&amp; opt.Ka){ shader.setFloat('Ka', opt.Ka);}
	if(use.Kd &amp;&amp; opt.Kd){ shader.setFloat('Kd', opt.Kd);}
	if(use.Ks &amp;&amp; opt.Ks){ shader.setFloat('Ks', opt.Ks);}
	if(use.Ns &amp;&amp; opt.Ns){ shader.setFloat('Ns', opt.Ns);}
	if(use.refract){ shader.setFloat('Tf', 1.0-opt.d); }
	if(use.Ka &amp;&amp; opt.map_Ka &amp;&amp; opt.map_Ka.texture) { shader.setTexture('map_Ka', opt.map_Ka.texture, slot); slot ++;}
	if(use.Kd &amp;&amp; opt.map_Kd &amp;&amp; opt.map_Kd.texture) { shader.setTexture('map_Kd', opt.map_Kd.texture, slot); slot ++;}
	if(use.Ks &amp;&amp; opt.map_Ks &amp;&amp; opt.map_Ks.texture) { shader.setTexture('map_Ks', opt.map_Ks.texture, slot); slot ++;}
	if(use.Ns &amp;&amp; opt.map_Ns &amp;&amp; opt.map_Ns.texture) { shader.setTexture('map_Ns', opt.map_Ns.texture, slot); slot ++;}
	if(use.d &amp;&amp; opt.map_d &amp;&amp; opt.map_d.texture) { shader.setTexture('map_d', opt.map_d.texture, slot); slot ++;}
	if((use.reflect || use.refract) &amp;&amp; opt.refl.texture){
		shader.setTexture('map_env', opt.refl.texture, slot); slot ++;
		shader.setMatrix('u_view', context.camera.getTransform().invert().elements);
	}
	if(use.dissolve) {
		shader.setFloat('dissolve', opt.d);
	}
	if(use.refract) {
		shader.setFloat('Tf', 1);
		shader.setFloat('Ni', opt.Ni);
	}
	(function(){
		var light, name, p;
		for(var i in lights){
			light = lights[i];
			name = "L"+i;
			if(use.Ka){shader.setColor3(name+'_col_a', light.color.ambient);}
			if (light.position &amp;&amp; (use.Ks || use.Kd)) {
				if(use.Kd){shader.setColor3(name+'_col_d', light.color.diffuse);}
				if(use.Ks){shader.setColor3(name+'_col_s', light.color.specular);}
				use.att = light.position &amp;&amp; light.position.w !== 0;
				if(!use.att) {
					p = new VG.Math.Vector3(light.position.x, light.position.y, light.position.z);
					p.normalize();
					shader.setFloat(name + '_pos', [p.x, p.y, p.z, 0.0]);
				} else {
					p = camera.getTransform().invert().multiplyPosition(light.position);
					shader.setFloat(name + "_pos", [p.x, p.y, p.z, p.w]);
					shader.setFloat(name + "_att_c", light.attenuation.constant);
					shader.setFloat(name + "_att_l", light.attenuation.linear);
					shader.setFloat(name + "_att_q", light.attenuation.quadratic);
					if (light.spot) {
						shader.setFloat(name + "_spot_cos", light.spot.cos_of_cutoff);
						shader.setFloat(name + "_spot_exp", light.spot.exponent);
						shader.setFloat(name + "_spot_dir", [light.spot.direction.x, light.spot.direction.y, light.spot.direction.z]);
					}
				}
			}
		}
	})();
};</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	ViralGraphics.io Copyright Â© 2014-2017 Markus Moenig
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a>
	
		on Wed Oct 11th 2017
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
